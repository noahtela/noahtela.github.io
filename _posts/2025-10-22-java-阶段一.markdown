---
layout:     post
title:      "java-阶段一"
subtitle:   " \"java\""
date:       2025-10-22 21:48:49
author:     "yangsir"
header-img: "img/bg-material.jpg"
catalog: true
tags:
    - 笔记
    - java



---

> “今日起，重学java”


<p id = "build"></p>

# java-阶段一

## 第一周

`print`和`println`

`println`换行

`print`不换行



数字不能作为标识符的首字母

`goto`保留字 不用做标识符



变量/常量

### 变量

三元素:变量类型、变量名、变量值

驼峰命名法

### 数据类型

- 基本数据类型
  - 数值型
    - 整型(byte、short、int、long)
    - 浮点类型(float、double)
  - 字符型(char)
  - 布尔型(boolean)
- 引用数据类型
  - 类
  - 接口
  - 数组

变量声明格式：数据类型 变量名;

`=` 赋值运算符

`==` 这才是等于

八进以`0`开头，16进制以`0x`开头



### 局部变量存储

内存里: 栈 常量池 堆

局部变量存在栈里



### 转义字符

`\'`表示’

`\"`表示"

`\n`表示换行

`\t`表示tab

```java
double d = 1.23E5 //表示1.23*10^5
```



### 类型转换

隐式(自动)类型转换   显式(强制)类型转换

范围小的可以隐式转换成范围大的

范围大的必须显式转换成范围小的

注意: int->float，long->float/double可能会造成数据丢失



### 常量

定义时比变量多一个`final`

例：

```java
final int n = 5;
```





### 表达式

运算符和操作数组成



### 运算符

- 算数运算符

  - 加减乘除 取余 自增自减

- 赋值运算符

- 关系运算符

  - 大于小于等于(==)不等于(!=)
  - 比较结果为布尔值

- 逻辑运算符

  - 与或非

- 条件运算符

  - 三目运算

    ```java
    //布尔表达式?表达式1:表达式2
    //当布尔表达式的值为true，则返回表达式1的值，否则返回表达式2的值
    ```

    

- 位运算符

`x++` 先参加运算，再++

`++x` 先++ 再参加运算

#### 运算符的优先级

圆括号-->逻辑非，自增，自减-->乘法，除法，取余-->加法，减法-->大于，大于等于-->等于，不等于-->逻辑与-->逻辑或-->赋值运算符，复合赋值运算符

### 流程控制

- 顺序

- 条件选择

  - if结构，if - else

  - 多重if，if - else if - else

  - 嵌套if

  - switch结构

    ```java
    switch(表达式){
    	case 常量表达式1:
    		语句1; break;
    	case 常量表达式2:
    		语句2; break; //break是跳出,不写的话会穿透
    	default:
    		语句3;
    	}
    ```

    `toUpperCase()`把字符串中的字符全部改为大写

## 第二周

### 循环

- for

  ```java
  for(表达式1;表达式2;表达式3)
  {
  	语句;
  }
  ```

- while

  ```java
  while(循环条件)
  {
  	语句;
  }
  ```

- do - while

  ```java
  do{
  	语句
  }while(循环条件);//与上一个不同，这个循环至少执行一次，注意最后的分号不要丢
  ```

- 循环嵌套

### debug基础

- 设置断点
- 调试模式

### 一维数组

- 数组的声明

  ```
  数据类型[] 数组名;
  数据类型 数组名[];
  ```

- 数组创建

  - 先声明后创建

  ```java
  数据类型[] 数组名;
  数组名 = new 数据类型[数组长度];
  ```

  注意：数组长度必须指定

- 数组在内存中的存储

  连续的 默认值为0或null

- 数组的初始化

  例：

  ```
  int[] arr ={1,2,3,4,5,6,7,8};
  ```

- 元素的引用

  数组名[下标];

### foreach循环

例:

```java
int[] arr = {1,2,3,4,5};
for(int n:arr)
	sout(n);
```



### 冒泡排序

从小到大

```java
public class ForDemo {
        public static void main(String[] args) {
            int[] arr = {34,53,12,56,32,17};
            for (int i = 0; i < arr.length-1; i++) {
                int temp;
                for (int j = 0; j < arr.length-1-i; j++) {
                    if (arr[j] > arr[j+1]) {
                        temp = arr[j];
                        arr[j] = arr[j+1];
                        arr[j+1] = temp;
                    }
                }
            }
            for (int i = 0; i < arr.length; i++) {
                System.out.println(arr[i]);
            }
        }

}
```





### 二维数组

多个一维数组，列可不一样



### 方法

什么是方法? 功能模块

- 方法的声明

  ```
  访问修饰符 返回类型 方法名(参数列表){
  	方法体
  }
  ```

  - 无参无返回值方法

    ```java
    public class ForDemo {
            public static void main(String[] args) {
                ForDemo fd = new ForDemo();
                fd.test();
            }
            void test(){
                System.out.println("***********");
                System.out.println("java");
                System.out.println("***********");
            }
    }
    ```

  - 无参带返回值方法

  - 带参无返回值方法

  - 带参带返回值方法

  - 方法的重载(方法参数的灵活性)

  写在**同一个类**中，方法名**必须相同**，参数列表**必须不同**

  注意:仅返回类型不同不算重载,可以有不同的访问修饰符

```java
class Calculator {
    // 方法重载
    public int add(int a, int b) {
        return a + b;
    }
    
    public double add(double a, double b) {
        return a + b;
    }
    
    public int add(int a, int b, int c) {
        return a + b + c;
    }
}
```

- 方法的传值

  普通数据类型+String，传入方法后，主方法中原参数不变，而数组类型会变

  String和数组都是引用类型数据，为什么效果不一样呢？

  ```java
  根本原因：
  String的不可变性 数组的可变性,String在方法中表现类似"值传递"，而数组表现真正的"引用传递"行为
  例:
  public class ParameterPassing {
      public static void main(String[] args) {
          // String示例
          String str = "hello";
          modifyString(str);
          System.out.println("修改后String: " + str); // 输出: hello
          
          // 数组示例  
          int[] arr = {1, 2, 3};
          modifyArray(arr);
          System.out.println("修改后数组: " + Arrays.toString(arr)); // 输出: [100, 2, 3]
      }
      
      public static void modifyString(String s) {
          s = "world"; // 创建了新对象，不影响原引用
      }
      
      public static void modifyArray(int[] array) {
          array[0] = 100; // 修改了原数组对象的内容
      }
  }
  ```

- 可变参数列表

  ```
  public void sum(int... n){}
  ```

  - 可变参数必须是最后一个
  - 一个方法只能有一个可变参数
  - 可变参数本质是数组
  - 优先匹配固定参数方法

  ```java
  public class VarargsDemo {
      
      // 可变参数方法
      public static void printNumbers(int... numbers) {
          for (int num : numbers) {
              System.out.print(num + " ");
          }
          System.out.println();
      }
      
      public static void main(String[] args) {
          printNumbers();           // 输出: (空行)
          printNumbers(1);          // 输出: 1
          printNumbers(1, 2);       // 输出: 1 2
          printNumbers(1, 2, 3, 4); // 输出: 1 2 3 4
      }
  }
  ```

  

## 第三周

### 类和对象

- 什么是面向对象? 关注事物信息

- 类 确定对象的特征+方法

- 对象是类的实例表现

  类---->实例化对象----->完成具体的程序

- 创建类与实例化对象

  ```java
  public class Person {
      // 属性（字段）
      String name;
      int age;
      
      // 方法
      public void introduce() {
          System.out.println("你好，我叫" + name + "，今年" + age + "岁。");
      }
      
      public void celebrateBirthday() {
          age++;
          System.out.println(name + "过生日啦！现在" + age + "岁了。");
      }
  }
  
  public class PersonTest {
      public static void main(String[] args) {
          // 实例化对象 - 使用 new 关键字
          Person person1 = new Person();
          
          // 设置对象的属性
          person1.name = "张三";
          person1.age = 25;
          
          // 调用对象的方法
          person1.introduce();
          person1.celebrateBirthday();
          
          // 创建另一个对象
          Person person2 = new Person();
          person2.name = "李四";
          person2.age = 30;
          person2.introduce();
      }
  }
  ```

  对象实例化后，对象的属性会有默认值(与方法不同)

- 单一职责原则

  一个类只有一个功能，只干一件事，功能越多，耦合越大，复用的可能性越低

  `PersonTest`如何找到的`Person`? 找本类，后找同一包

- new

  - 声明对象 `Person person1` 仅仅是栈中开辟空间，还不能真正使用
  - 实例化对象 `new Person();`堆中存数据，实例化后，栈中对象指向堆中的数据地址
  - 同一作用范围内，不能定义同名对象

### 堆与栈

- 当存储内容是由基本数据类型(byte、short、int、long、fioat、double、char、bolean)声明的局部变量时，在栈中存储的是它们对应的具体数值。
- 当存储的是局部的对象的引用(定义在方法体中的引用类型的变量)，存储的是具体对象在堆中的地址。当然，如果对象的引用没有指向具体的空间，则是null。

### 构造方法

- 构造方法与类同名且**没有返回值**

- 构造方法的语法格式

  ```java
  public 构造方法名(){
  	//初始化代码
  }
  ```

- 只有在对象实例化的时候被调用

- 当没有指定构造方法时，系统会自动添加无参的构造方法

- 当有指定构造方法，无论是有参、无参的构造方法，都不会自动添加无参的构造方法

- 一个类中可以有多个构造方法(重载)

### 封装

- 将类的某些信息隐藏在类内部，不允许外部程序直接访问
- 通过该类提供的方法来实现对隐藏信息的操作和访问
- 隐藏对象的信息
- 留出访问的接口

### 封装的代码实现

- 修改属性的可见性(private)，限定只能在当前类内访问 
- 创建getter/setter方法(public)
- 在getter/setter方法中加入属性控制语句

```java
public class Student {
    // 私有属性 - 外部无法直接访问
    private String name;
    private int age;
    private double gpa;
   
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
            this.name = name;
    }
    
    public int getAge() {
        return age;
    }
    
    public void setAge(int age) {
        if (age >= 0 && age <= 120) {
            this.age = age;
        } else {
            System.out.println("年龄必须在0-120之间！");
        }
    }
    
    public double getGpa() {
        return gpa;
    }
    
    public void setGpa(double gpa) {
            this.gpa = gpa;
    }
}
//测试类
public class StudentTest {
    public static void main(String[] args) {
        // 创建学生对象
        Student student = new Student();
        // 使用setter方法修改属性
        student.setAge(21);
        student.setGpa(3.9);
        student.setName("李四");
        // 调用getter方法
        System.out.println("学生1 - 姓名: " + student.getName() + 
                          ", 年龄: " + student.getAge() + 
                          ", GPA: " + student.getGpa());
    }
}
```



### 包

- Java中一个包里不能存在同名类
- 命名：域名倒序+模块+功能
- 导包用import
- 加载类的顺序跟import导入语句的位置无关,先找直接能解析的类
- `import 包名.*;` 只能访问指定包名下的类，无法访问子包下的类

### static关键字

- 表示静态信息，静态成员/类成员/全局属性
- 类对象共享
- 类加载时产生，销毁时释放，生命周期长
- 静态成员访问方式
  - 对象.成员
  - 类.成员
- 通过该类实例化的所有对象都共享类中静态资源，任一对象中信息的修订都将影响所有对象。
- 静态方法中不能直接调用同一类中的非静态成员，只能通过对象实例化
- 构造代码块--创建对象时调用，优先于构造方法执行(与构造方法同级)，每次实例化的时候都会执行
- 静态代码块--创建对象时调用，优先于构造代码块执行，多个按顺序执行，无论实例化多少对象，只执行一次，只能访问静态成员

### 继承

- 利用代码复用，缩短开发周期
- 一种类与类之间的关系
- 使用已存在的类的定义作为基础建设新类
- 子类的定义可以增加新的数据或功能，也可以使用父类的功能，但不能选择性的继承父类

### 继承的实现

- 简单演示

```java
//父类
class Animal{
	//公共的属性和方法
}

//子类
class Dog extends Animal{
    //子类特有的属性和方法
}
class Cat extends Animal{
}

```

- 一个子类只能有唯一父类

### 方法的重写

- 在子类中定义
- 方法名、参数(类型、顺序、个数)都要和父类相同，参数名不做要求
- 当子类重写父类方法后，子类对象调用的是重写后的方法
- 当方法返回值是void或基本数据类型时，不允许修改；当返回值是引用类型时，可以是父类或其子类
- 访问修饰符需要大于等于父类的访问修饰符
- 静态方法不能重写

### 访问修饰符

- 公有(public)：允许在任意位置访问
- 私有(private)：只允许在本类中进行访问
- 受保护的(protected)：允许在同类、同包子类/非子类、跨包子类调用
- 默认(啥也不写)：允许在当前类、同包子类/非子类调用，不允许跨包

### super关键字

在子类中，如果一个方法重写后，子类中另一个方法仍然想调用继承下来的同名方法，可以使用`super.方法名`

### 继承后的初始化顺序

父类静态成员--->子类静态成员-->父类对象构造-->子类对象构造

**子类构造默认调用父类无参构造方法，可以用super指定调用父类的哪个构造方法**

```java
// 父类
class Parent {
    private String name;
    private int age;
    
    // 父类无参构造方法
    public Parent() {
        this.name = "未知";
        this.age = 0;
        System.out.println("调用了父类无参构造方法");
    }
    
    // 父类有参构造方法
    public Parent(String name, int age) {
        this.name = name;
        this.age = age;
        System.out.println("调用了父类有参构造方法：name=" + name + ", age=" + age);
    }
}

// 子类
class Child extends Parent {
    private String hobby;
    
    // 子类构造方法1：默认调用父类无参构造方法（隐式调用）
    public Child(String hobby) {
        // 这里隐式调用了 super()，即父类的无参构造方法
        this.hobby = hobby;
        System.out.println("调用了子类构造方法1，hobby=" + hobby);
    }
    
    // 子类构造方法2：使用super显式调用父类有参构造方法
    public Child(String name, int age, String hobby) {
        super(name, age); // 显式调用父类有参构造方法，必须放在第一行
        this.hobby = hobby;
        System.out.println("调用了子类构造方法2，hobby=" + hobby);
    }
}
```

## 第四周

### Object类

- object类是所有类的父类

- 一个类没有使用extends关键字明确标识继承关系，则默认继承Object类(包括数组)

- Java中的每个类都可以使用Object中定义的方法

- 继承object中的equals方法时，比较的是两个引用是否指向同一个对象

- 子类可以通过重写equals方法的形式，改变比较的内容

- 字符串重写了equals方法，比较的是内容

- 输出对象名时，默认会直接调用类中的toString方法，object类中的toString方法是打印包名@内存地址哈希，在实体类中经常被重写

  > 问:`==`到底比较的是值还是地址呢?
  >
  > 答：比较的是变量中存储的值，对于基本数据类型，比较栈中的实际数值，引用数据类型 - 比较栈中存储的引用地址

### final关键字

- final class表示该类没有子类，禁止继承
- final 方法表示该方法不能被子类重写，但是不影响子类继承使用(不能修饰构造方法)，禁止重写
- final 局部变量 表示该变量只能被赋值一次，变为常量
- final 对象属性亦如此，但是有三种赋值方式：1、定义时赋值 2、构造方法中赋值3、构造代码块中赋值
- 可配合static使用，表示全局加载一次且不能被修改

### 注解

- 可以声明在包、类、属性、方法、局部变量、方法参数等的前面，用来对这些元素进行说明、注释
- 按照运行机制分为三类
  - 源码注解:注解只在源码阶段保留在编译阶段会被丢弃
  - 编译时注解
  - 运行时注解：在运行阶段还起作用，甚至会影响运行逻辑的注解。
- 按照来源分
  - 来自JDK的注解
  - 来自第三方的注解
  - 我们自己定义的注解

### Java单例模式

- 什么是设计模式？设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。
- 目的:使得类的一个对象成为该类系统中的唯一实例
- 一个类有且只有一个实例，并且自行实例化向整个系统提供
- 实现：
  1. 只提供私有的构造方法
  2. 含有一个该类的静态私有对象
  3. 提供一个静态的共有方法用于创建、获取静态私有对象
- 优：
  - 在内存中只有一个对象，节省内存空间
  - 避免频繁的创建销毁对象，提高性能
  - 避免对共享资源的多重占用
- 缺：
  - 扩展困难
  - 如果实例化后的对象长期不利用，系统将默认为垃圾进行回收，造成对象状态丢失

### 饿汉式单例模式

- 对象创建过程中实例化
- 空间换时间

代码实现演示:

```java
package com.qy.singleton;

public class SingletonOne {
    //创建私有构造方法
    private SingletonOne() {
    }
    //私有静态实例化对象
    private  static SingletonOne singletonOne = new SingletonOne();

    //共有静态方法返回静态实例对象
    public static SingletonOne getSingleton(){
        return singletonOne;
    }

}

package com.qy.test;

import com.qy.singleton.SingletonOne;

public class SingletTest {
    public static void main(String[] args) {
        //使用类.方法调用
        SingletonOne one = SingletonOne.getSingleton();
        SingletonOne two = SingletonOne.getSingleton();

        System.out.println(one);
        System.out.println(two);

    }
}

```

![image-20251025185442620](\img\linux\image-20251025185442620.png)

### 懒汉式单例模式

- 静态公有方法中实例化

- 类内实例对象创建时并不直接初始化，直到第一次调用get方法时，才完成初始化操作

- 时间换空间

- 存在线程风险
  - 同步锁
  
  - 双重校验锁
  
    ```java
    public class DoubleCheckedLockingSingleton {
        // 使用volatile确保多线程环境下的可见性和有序性
        private static volatile DoubleCheckedLockingSingleton instance;
        
        private DoubleCheckedLockingSingleton() {
            // 私有构造函数
        }
        public static DoubleCheckedLockingSingleton getInstance() {
            if (instance == null) { // 第一次检查
                synchronized (DoubleCheckedLockingSingleton.class) {
                    if (instance == null) { // 第二次检查
                        instance = new DoubleCheckedLockingSingleton();
                    }
                }
            }
            return instance;
        }
    }
    ```
  
  - 静态内部类
  
  - 枚举

代码实现:

```java
package com.qy.singleton;
public class SingletonTwo {
    //创建私有构造方法
    private SingletonTwo() {
    }
    //私有静态实例化对象
    private  static SingletonTwo singletonTwo;

    //共有静态方法返回静态实例对象
    public static SingletonTwo getSingleton(){
        if(singletonTwo == null){  //如果不加判断，就违背了单例模式的初衷，重复创建和销毁对象
            singletonTwo = new SingletonTwo();
        }
        return singletonTwo;
    }
}

package com.qy.test;
import com.qy.singleton.SingletonTwo;

public class SingletTest {
    public static void main(String[] args) {
        //使用类.方法调用
        SingletonTwo singletonOne = SingletonTwo.getSingleton();
        SingletonTwo singletonTwo = SingletonTwo.getSingleton();
        System.out.println(singletonOne);
        System.out.println(singletonTwo);

    }
}
```



### 多态

> 问：你怎么理解多态的?
>
> 答：说到多态，就不得不提到方法的重写和重载，重写和重载就是多态的具体体现，简单来说，多态就是一个方法名，多种实现，首先从重写的方面，比如说我有一个父类，定义了Hello方法，打印hello1，子类里我重写了这个方法，打印hello2，同时实例化子类和父类，调用Hello方法，打印的是不同内容，这就是多态的表现。

封装和继承--为多态而生

- 同一个方法调用，作用于不同对象时，会产生不同的行为。
- 一个方法名，多种实现。
- 编译时多态
- 运行时多态
- 必要条件：
  - 满足继承关系
  - 父类引用指向子类对象

演示代码

```java
package com.qy.polymorphic;

public class Animal {

    private String name;
    private int age;

    public Animal() {
    }

    public Animal(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public void eat() {
        System.out.println("动物都要吃东西");
    }

}
```

```java
package com.qy.polymorphic;

public class Cat extends Animal {

    private String sex;

    public Cat() {
    }

    public Cat(String name, int age, String sex) {
        super(name, age);
        this.sex = sex;
    }

    public String getSex() {
        return sex;
    }

    public void setSex(String sex) {
        this.sex = sex;
    }

    @Override
    public void eat() {
        System.out.println("猫吃鱼");
    }
}

```

```java
package com.qy.polymorphic;

public class Dog extends Animal{
    private int weight;

    public Dog() {
    }

    public Dog(String name, int age, int weight) {
        super(name, age);
        this.weight = weight;
    }

    public int getWeight() {
        return weight;
    }

    public void setWeight(int weight) {
        this.weight = weight;
    }

    @Override
    public void eat() {
        System.out.println("狗吃肉");
    }
}

```

```java
package com.qy.test;

import com.qy.polymorphic.Animal;
import com.qy.polymorphic.Cat;
import com.qy.polymorphic.Dog;

public class PolymorphicTest {

    public static void main(String[] args) {
        Animal animal = new Animal();
        //向上转型
        Animal animal2 = new Cat();
        Animal animal3 = new Dog();
        animal.eat();
        animal2.eat();
        animal3.eat();
        //向下转型
        Cat cat = (Cat) animal2;
        cat.eat();
        cat.run();
        //报错
        Cat cat1 = (Cat) animal;
        cat1.eat();
        cat1.run();
        //报错
        Cat cat2 = (Cat) animal3;
        cat2.eat();
        cat2.run();
    }
}

```

输出结果：

![image-20251026112031951](\img\linux\image-20251026112031951.png)



### 向上转型

- 隐式转型/自动转型

- 父类引用指向子类实例

  ```java
  Animal animal2 = new Cat();
  ```

- 小类转为大类

- 可以调用子类重写父类的方法以及父类派生的方法，无法调用子类独有方法

- 目的：实现多态、编写通用代码、方法参数通用化

### 向下转型

- 子类引用指向父类对象，此处必须进行强转，可以调用子类特有的方法
- 必须存在继承关系。只能将父类引用转为它真正的、具体的子类类型。
- 目的：恢复对子类特有方法和字段的访问权限

```java
if (父类引用 instanceof 子类类型) {
    // 安全地进行转换
    子类类型 变量 = (子类类型) 父类引用;
}
```

### instanceof运算符

- 返回布尔值

- 检查一个对象是否是指定类型（类、子类或接口）的实例

  ```
  对象引用 instanceof 类型（类或接口）
  ```

### abstract 

- 这个关键词修饰的类，叫抽象类，抽象方法同理

### 抽象类

- 不允许实例化，但是可以通过向上转型，指向子类实例
- 适用：某个父类只是知道其子类应该包含怎样的方法，但无法准确知道这些子类如何实现这些方法。
- static、final、private不能与abstract共存

### 抽象方法

abstract修饰的方法叫做抽象方法

- 抽象方法不允许包含方法体
- 子类中需要重写父类的抽象方法
- 包含抽象方法的类必须是抽象类
- 抽象类中可以没有抽象方法



### 接口

- 接口定义了某一批类所需要遵守的规范

- 接口不关心这些类的内部数据，也不关心这些类里方法的实现细节，它只规定这些类里必须提供某些方法。

- 命名习惯，在类的命名规则基础上，加个I

- 访问修饰符默认或public

- 接口中抽象方法可以不写`abstract`关键字

- 当类实现接口时，需要去实现接口中的所有抽象方法，否则需要将该类设置成抽象类

- 接口中可以包含常量，默认`public static final`

- 接口中的一般方法，不能有方法体，实现类必须重写这些方法，例外:默认方法，可以有方法体，实现类里也可以不用重写该方法，如`connectiond()`

- 在多接口的实现类里面，如果接口里有同名的默认方法，则在业务中调用的时候会报错(不知道调哪个)，解决方案:在实现类里重写该方法

  ```java
  //接口访问修饰符:public或默认
  public interface INet {
      /*接口中抽象方法可以不写abstract关键字
      *访问修饰符默认public
      *当类实现接口时，需要去实现接口中的所有抽象方法，否则需要将该类设置为抽象类
      */
      //实现类必须重写
      void network();
  	//接口中可以包含常量，默认public static finalint TEMP-20;
      int TEMP=20;
      //默认方法,实现类可以重写，也可以不重写，可以通过接口的引用调用
      default void connectiond(){
          System.out.println("我是默认方法");
      };
      //静态方法,实现类不可重写，可以用接口名调用
      static void stop(){
          System.out.println("我是默认方法");
      }
  }
  ```

  

- 一个类可以既继承`extends`又实现接口`implements`，但是继承必须写在接口前，如果父类和接口中的默认方法有同名方法，接口中的默认方法不生效

  ```java
  public class 类名 extends 父类 implements 接口1,接口2...
  ```

- 实现接口需要使用implements

- 接口类也可以实现继承，且可以继承多个父接口

- 当多个接口或父类有同名常量时，与方法不同，实现类中无法识别同名常量是哪个，可以用以下方式区分

  ```java
  interface InterfaceA {
      int VALUE = 10;
  }
  
  interface InterfaceB {
      int VALUE = 20;
  }
  
  class Parent {
      public static final int VALUE = 30;
  }
  
  // 常量冲突 - 必须明确指定来源
  class ConflictClass extends Parent implements InterfaceA, InterfaceB {
      public void showValues() {
          System.out.println("父类VALUE: " + Parent.VALUE);
          System.out.println("接口A VALUE: " + InterfaceA.VALUE);
          System.out.println("接口B VALUE: " + InterfaceB.VALUE);
          
          // 直接使用VALUE会有歧义，编译错误
          // System.out.println("VALUE: " + VALUE); // 编译错误
      }
  }
  ```

  

> 在java中，实现类实现接口和子类继承父类有什么区别？
>
> - **继承**：用于建立"是什么"的关系，强调代码复用和层次结构
> - **接口**：用于建立"能做什么"的关系，强调行为契约和多态性
> - **实际开发**：通常结合使用，用继承建立核心层次结构，用接口扩展额外能力
> - **设计原则**：优先使用接口组合，减少深层次的继承关系，提高代码灵活性

| 特性         | 继承父类             | 实现接口                        |
| :----------- | :------------------- | :------------------------------ |
| **关系类型** | "is-a" 关系          | "has-a" 能力                    |
| **数量限制** | 单继承               | 多实现                          |
| **方法实现** | 可以继承具体实现     | 必须实现所有抽象方法            |
| **构造方法** | 可以继承             | 没有构造方法                    |
| **字段**     | 可以继承实例变量     | 只能有常量(public static final) |
| **设计目的** | 代码复用、层次化设计 | 定义契约、多态行为              |



### 内部类

- 成员内部类

  - 也称普通内部类

  - 内部类在外部使用时无法直接实例化，需要借由外部类信息才能完成实例化

  - 内部类可以直接访问外部类的成员(属性，方法)

    ```java
    // 外部类
    class OuterClass {
        private String outerField = "外部类字段";
        
        // 成员内部类
        class InnerClass {
            private String innerField = "内部类字段";
            
            public void display() {
                // 内部类可以访问外部类的私有成员
                System.out.println("访问外部类字段: " + outerField);
                System.out.println("内部类字段: " + innerField);
            }
        }
        
        // 外部类方法：创建内部类实例
        public void createInner() {
            InnerClass inner = new InnerClass();
            inner.display();
        }
    }
    
    // 测试类
    public class Test {
        public static void main(String[] args) {
            OuterClass outer = new OuterClass();
            // 方式1：通过外部类实例创建内部类
            OuterClass.InnerClass inner1 = outer.new InnerClass();
            inner1.display();
            
            // 方式2：在外部类内部创建（如createInner方法中）
            outer.createInner();
        }
    }
    ```

- 静态内部类

  - 静态内部类中，只能直接访问外部类的静态成员，如果需要调用非静态成员，可以通过对象实例

  - 实例化静态内部类对象实例时，可以不依赖于外部类对象

  - 可以通过外部类,内部类.静态成员的方式，访问内部类中的静态成员

    ```java
    class OuterClass {
        private static String staticField = "静态字段";
        private String instanceField = "实例字段";
        
        // 静态内部类
        static class StaticInnerClass {
            public void display() {
                // 只能访问外部类的静态成员
                System.out.println("静态字段: " + staticField);
                // System.out.println(instanceField); // 错误！不能访问实例成员
            }
        }
    }
    
    // 测试
    public class Test {
        public static void main(String[] args) {
            // 静态内部类实例化：不需要外部类实例
            OuterClass.StaticInnerClass staticInner = new OuterClass.StaticInnerClass();
            staticInner.display();
        }
    }
    ```

- 方法内部类

  - 局部内部类

  - 定义在方法内部，作用范围也在方法内

  - 类中不能包含静态成员

  - 和方法内部成员使用规则一样，class前面不可以添加public、private、protected、static

    ```java
    class OuterClass {
        private String outerField = "外部字段";
        
        public void method() {
            String localVar = "局部变量"; // 必须是final或等效final
            
            // 局部内部类
            class LocalInnerClass {
                public void display() {
                    System.out.println("外部字段: " + outerField);
                    System.out.println("局部变量: " + localVar); // JDK8+ 自动视为final
                }
            }
            
            // 在方法内部实例化
            LocalInnerClass localInner = new LocalInnerClass();
            localInner.display();
        }
    }
    
    // 测试
    public class Test {
        public static void main(String[] args) {
            OuterClass outer = new OuterClass();
            outer.method(); // 在method内部实例化局部内部类
        }
    }
    ```

- 匿名内部类

  - 只用到类的一个实例

  - 类在定义后马上用到

  - 给类命名并不会导致代码更容易被理解

    ```java
    // 接口
    interface Greeting {
        void greet();
    }
    
    class OuterClass {
        public void createAnonymousClass() {
            // 匿名内部类：实现Greeting接口
            Greeting greeting = new Greeting() {
                @Override
                public void greet() {
                    System.out.println("Hello from anonymous inner class!");
                }
            };
            
            greeting.greet();
            
            // 另一种写法：直接调用
            new Greeting() {
                @Override
                public void greet() {
                    System.out.println("直接创建的匿名类");
                }
            }.greet();
        }
    }
    
    // 测试
    public class Test {
        public static void main(String[] args) {
            OuterClass outer = new OuterClass();
            outer.createAnonymousClass();
        }
    }
    ```

## 第五周

### 异常

- 什么是异常？程序错误
- 背离我们程序本身的意图的表现
- 异常的分类
  - `Throwable`:异常的根类
  - `Error`类:表示程序无法处理的错误，表示运行应用程序中较严重问题，常见：
    - `VirtualMachineError`虚拟机错误
    - `OutOfMemoryError`内存溢出
    - `ThreadDeath`线程死锁
  - `Exception`是程序本身可以处理的异常。异常处理通常指针对这种类型异常的处理。
- 异常处理机制
  - 抛出异常-->捕获异常
- 对于可查异常必须捕捉、或者声明抛出
- 允许忽略不可查的RuntimeException(含子类)和Error(含子类)
- 捕获异常：`try`(执行可能产生异常的代码)--`catch`(捕获异常)---`finally`(无论是否发生异常代码总能执行)
- 声明异常：`throws`声明可能要抛出的异常
- 手动抛出异常`throw`

### `try`--`catch`---`finally`

- `try`块后可接零个或多个`catch`块，如果没有`catch`块则必须跟一个`finally`块。

- 常见异常类型：

  - `ArithmeticException`：数学运算异常，涉及到数学运算的地方可能出现失误，比如程序中出现了除以零这样的运算
  - `NumberFormatException`:数字格式化异常，涉及到类型转换时，比如不符合转换格式的字符串被转换成数字
  - `ArraylndexOutOfBoundsException`：数组下标越界异常，涉及到使用超出数组下标范围的下标。
  - `NullPointerException`：空指针异常，当使用了未经初始化的对象或者是不存在的对象时。
  - `ClassCastException`:类型转换异常，如进行向下转型时，转换对象无法完成正常转换。

  ```java
  import java.util.Scanner;
  import java.util.InputMismatchException;
  
  public class TryDemoOne {
      public static void main(String[] args) {
          // 要求：定义两个整数，接受用户的键盘输入，输出两数之商
          Scanner input = new Scanner(System.in);
          System.out.println("=====运算开始=====");
          try {
              System.out.print("请输入第一个整数：");
              int one = input.nextInt();
              System.out.print("请输入第二个整数：");
              int two = input.nextInt();
              System.out.println("one和two的商是：" + (one / two));
          } catch (ArithmeticException e) {
              System.out.println("除数不允许为零");
              e.printStackTrace();
          } catch (InputMismatchException e) {
              System.out.println("请输入整数");
              e.printStackTrace();//输出异常
          }catch(Exception e){//一般在最后一个异常父类，防止前面异常捕获不到，而且父类catch块只能写到子类后面
              e.printStackTrace(); 
              System.out.println("出错啦~~");
          }
          finally {
              System.out.println("=====运算结束=====");
              input.close();
          }
      }
  }
  ```

- 当`try`、`catch`、`finally`中都有return的时候，`try`/`catch`中的返回会被finally中的覆盖掉

- 即便在`try`、`catch`中写了`return`,finally块也会正常执行

### throws

- 可以通过throws声明将要抛出何种类型的异常，通过throw将产生的异常抛出

- 如果一个方法可能会出现异常，但没有能力处理这种异常，可以在方法声明处用throws子句来声明抛出异常。

- throws语句用在方法定义时声明该方法要抛出的异常类型

- 区别于`try`、`catch`、`finally`，throws关注的是将异常传递给调用者处理，而前者是在当前方法中立即处理异常

  ```
  public void method() throws Exception1,Exception2,...,ExceptionN{
  // 可能产生异常的代码
  }
  ```

  ```java
  import java.util.Scanner;
  import java.util.InputMismatchException;
  
  public class TryDemoTwo {
      
      public static void main(String[] args) {
          Scanner input = new Scanner(System.in);
          System.out.println("=====运算开始=====");
          
          try {
              // 调用可能抛出异常的方法
              performCalculation(input);
          } catch (ArithmeticException e) {
              System.out.println("除数不允许为零");
              e.printStackTrace();
          } catch (InputMismatchException e) {
              System.out.println("请输入整数");
              e.printStackTrace();
          } catch (Exception e) {
              System.out.println("出错啦~~");
              e.printStackTrace();
          } finally {
              System.out.println("=====运算结束=====");
              input.close();
          }
      }
      
      // 这个方法使用throws声明可能抛出的异常
      // 它不自己处理异常，而是让调用者来处理
      public static void performCalculation(Scanner input) 
              throws ArithmeticException, InputMismatchException {
          System.out.print("请输入第一个整数：");
          int one = input.nextInt();  // 可能抛出InputMismatchException
          System.out.print("请输入第二个整数：");
          int two = input.nextInt();  // 可能抛出InputMismatchException
          System.out.println("one和two的商是：" + (one / two));  // 可能抛出ArithmeticException
      }
  }
  ```

  

### throw

- `throw`用来抛出一个异常。

- 例如:throw new IOException();

- throw 抛出的只能是Throwable类或者其子类的实例对象。

- 处理特殊业务逻辑产生的需求

- 分两种

  - 通过`try...catch`语句包含`throw`---------自己抛出异常自己处理
  - 通过throws在方法声明出抛出异常类型-------自己抛出异常由调用者处理

  

  

### 自定义异常

- 描述特定业务产生的异常类型
- 定义一个类，继承Throwable或者它的子类
- 自定义异常是否属于检查异常由其父类决定
- `e.toString()`:获得异常类型和描述信息，当直接输出对象e时，默认调用e.toString()方法。
- `e.getMessage()`:获得异常描述信息
- `e.printStackTrace():`打印出异常产生的堆栈信息，包括种类、描述信息、出错位置等
- 自定义异常需先经过throw抛出，才能被catch捕获，是无法自动被程序捕获并处理的。



### 异常链

将异常发生的原因一个传一个串起来，把底层的异常信息传给上层，这样逐层抛出。

> 异常链的存在目的是什么?
>
> 这是异常链最主要、最重要的目的。在复杂的系统或多层架构中（如Web应用的分层架构：Controller -> Service -> DAO），底层的异常（如数据库连接失败）在向上传递时，可能会被捕获并包装成更抽象的、对当前层有意义的异常。比如没有异常链，在顶层你只能看到“业务处理失败”，但不知道是为什么失败。有异常链：在顶层你看到“业务处理失败”，但通过异常链可以追溯到“数据访问失败”，再进一步追溯到“网络连接超时”。这让你能快速定位到是数据库服务器或网络的问题。

###   包装类

- 包装类与基本数据类型

  | 基本类型 | 对应包装类 |
  | -------- | ---------- |
  | byte     | Byte       |
  | short    | Short      |
  | int      | Integer    |
  | long     | Long       |
  | float    | Float      |
  | double   | Double     |
  | char     | Character  |
  | boolean  | Boolean    |

- 装箱

  基本数据类型的值转换成对应包装类的对象

- 拆箱

  包装类的对象转换成基本数据类型的值

  ```java
  public class TestOne {
      public static void main(String[] args) {
          int t1 = 2;
          //自动装箱
          Integer t2 = t1;
          //手动装箱
          Integer t3 = new Integer(t1);
          Integer t4 = Integer.valueOf(t1);
          System.out.println(t2);
          System.out.println(t3);
          System.out.println(t4);
          System.out.println("********");
          //自动拆箱
          int t5 = t3;
          //手动拆箱
          int t6 = t4.intValue();
          double t7 = t4.doubleValue();
          System.out.println(t5);
          System.out.println(t6);
          System.out.println(t7);
      }
  ```

  ![image-20251029212831578](\img\linux\image-20251029212831578.png)

- 基本数据类型与字符串之间的转换

  ```java
  public class TestOne {
      public static void main(String[] args) {
          int t1 = 2;
          String t2 = Integer.toString(t1);
          System.out.println(t2);
  
          int t3 = Integer.parseInt(t2);
          int t4 = Integer.valueOf(t2);
  
          double t5 = Double.valueOf(t2);
          double t6 = Double.parseDouble(t2);
  
          System.out.println(t3);
          System.out.println(t4);
          System.out.println(t5);
          System.out.println(t6);
  
      }
  ```

- 包装类如果不进行初始化，值为NULL

  ```java
  public class TestOne {
      public static void main(String[] args) {
          Integer one=new Integer(100);
          Integer two=new Integer(100);
          System.out.println("one==two的结果: "+(one==two));//false
  
          Integer three=100;//自动装箱
          //Integer three=Integer.valueOf(100);
          System.out.println("three==100的结果: "+(three==100));//true 自动拆箱
  
          //Integer four=100;
          Integer four=Integer.valueOf(100);
          System.out.println("three==four的结果: "+(three==four));//true
  
          Integer five=200;
          System.out.println("five==200的结果: "+(five==200));// true
  
          Integer six=200;
          System.out.println("five==six的结果: "+(five==six));// false
  
      }
  
  }
  ```

- 如上代码，在针对自动拆箱的时候，`Integer three=100;`实际执行的是`Integer three=Integer.valueOf(100);`，而`.valueOf()`中的参数小于等于127或大于等于-128时，会将对象缓存在缓存区(对象池)，下面再有`valueOf()`时，如果在这个区间内，会优先在缓存区检查有无已存在的相同对象，若有，直接引用，如无，隐式调用`new`,不过Double和Float类型没有缓存区这个概念

