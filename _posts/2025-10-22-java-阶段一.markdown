---
layout:     post
title:      "java-阶段一"
subtitle:   " \"java\""
date:       2025-10-22 21:48:49
author:     "yangsir"
header-img: "img/bg-material.jpg"
catalog: true
tags:
    - 笔记
    - java



---

> “今日起，重学java”


<p id = "build"></p>

# java-阶段一

## 第一周

`print`和`println`

`println`换行

`print`不换行



数字不能作为标识符的首字母

`goto`保留字 不用做标识符



变量/常量

### 变量

三元素:变量类型、变量名、变量值

驼峰命名法

### 数据类型

- 基本数据类型
  - 数值型
    - 整型(byte、short、int、long)
    - 浮点类型(float、double)
  - 字符型(char)
  - 布尔型(boolean)
- 引用数据类型
  - 类
  - 接口
  - 数组

变量声明格式：数据类型 变量名;

`=` 赋值运算符

`==` 这才是等于

八进以`0`开头，16进制以`0x`开头



### 局部变量存储

内存里: 栈 常量池 堆

局部变量存在栈里



### 转义字符

`\'`表示’

`\"`表示"

`\n`表示换行

`\t`表示tab

```java
double d = 1.23E5 //表示1.23*10^5
```



### 类型转换

隐式(自动)类型转换   显式(强制)类型转换

范围小的可以隐式转换成范围大的

范围大的必须显式转换成范围小的

注意: int->float，long->float/double可能会造成数据丢失



### 常量

定义时比变量多一个`final`

例：

```java
final int n = 5;
```





### 表达式

运算符和操作数组成



### 运算符

- 算数运算符

  - 加减乘除 取余 自增自减

- 赋值运算符

- 关系运算符

  - 大于小于等于(==)不等于(!=)
  - 比较结果为布尔值

- 逻辑运算符

  - 与或非

- 条件运算符

  - 三目运算

    ```java
    //布尔表达式?表达式1:表达式2
    //当布尔表达式的值为true，则返回表达式1的值，否则返回表达式2的值
    ```

    

- 位运算符

`x++` 先参加运算，再++

`++x` 先++ 再参加运算

#### 运算符的优先级

圆括号-->逻辑非，自增，自减-->乘法，除法，取余-->加法，减法-->大于，大于等于-->等于，不等于-->逻辑与-->逻辑或-->赋值运算符，复合赋值运算符

### 流程控制

- 顺序

- 条件选择

  - if结构，if - else

  - 多重if，if - else if - else

  - 嵌套if

  - switch结构

    ```java
    switch(表达式){
    	case 常量表达式1:
    		语句1; break;
    	case 常量表达式2:
    		语句2; break; //break是跳出,不写的话会穿透
    	default:
    		语句3;
    	}
    ```

    `toUpperCase()`把字符串中的字符全部改为大写

## 第二周

### 循环

- for

  ```java
  for(表达式1;表达式2;表达式3)
  {
  	语句;
  }
  ```

- while

  ```java
  while(循环条件)
  {
  	语句;
  }
  ```

- do - while

  ```java
  do{
  	语句
  }while(循环条件);//与上一个不同，这个循环至少执行一次，注意最后的分号不要丢
  ```

- 循环嵌套

### debug基础

- 设置断点
- 调试模式

### 一维数组

- 数组的声明

  ```
  数据类型[] 数组名;
  数据类型 数组名[];
  ```

- 数组创建

  - 先声明后创建

  ```java
  数据类型[] 数组名;
  数组名 = new 数据类型[数组长度];
  ```

  注意：数组长度必须指定

- 数组在内存中的存储

  连续的 默认值为0或null

- 数组的初始化

  例：

  ```
  int[] arr ={1,2,3,4,5,6,7,8};
  ```

- 元素的引用

  数组名[下标];

### foreach循环

例:

```java
int[] arr = {1,2,3,4,5};
for(int n:arr)
	sout(n);
```



### 冒泡排序

从小到大

```java
public class ForDemo {
        public static void main(String[] args) {
            int[] arr = {34,53,12,56,32,17};
            for (int i = 0; i < arr.length-1; i++) {
                int temp;
                for (int j = 0; j < arr.length-1-i; j++) {
                    if (arr[j] > arr[j+1]) {
                        temp = arr[j];
                        arr[j] = arr[j+1];
                        arr[j+1] = temp;
                    }
                }
            }
            for (int i = 0; i < arr.length; i++) {
                System.out.println(arr[i]);
            }
        }

}
```





### 二维数组

多个一维数组，列可不一样



### 方法

什么是方法? 功能模块

- 方法的声明

  ```
  访问修饰符 返回类型 方法名(参数列表){
  	方法体
  }
  ```

  - 无参无返回值方法

    ```java
    public class ForDemo {
            public static void main(String[] args) {
                ForDemo fd = new ForDemo();
                fd.test();
            }
            void test(){
                System.out.println("***********");
                System.out.println("java");
                System.out.println("***********");
            }
    }
    ```

  - 无参带返回值方法

  - 带参无返回值方法

  - 带参带返回值方法

  - 方法的重载(方法参数的灵活性)

  写在**同一个类**中，方法名**必须相同**，参数列表**必须不同**

  注意:仅返回类型不同不算重载,可以有不同的访问修饰符

```java
class Calculator {
    // 方法重载
    public int add(int a, int b) {
        return a + b;
    }
    
    public double add(double a, double b) {
        return a + b;
    }
    
    public int add(int a, int b, int c) {
        return a + b + c;
    }
}
```

- 方法的传值

  普通数据类型+String，传入方法后，主方法中原参数不变，而数组类型会变

  String和数组都是引用类型数据，为什么效果不一样呢？

  ```java
  根本原因：
  String的不可变性 数组的可变性,String在方法中表现类似"值传递"，而数组表现真正的"引用传递"行为
  例:
  public class ParameterPassing {
      public static void main(String[] args) {
          // String示例
          String str = "hello";
          modifyString(str);
          System.out.println("修改后String: " + str); // 输出: hello
          
          // 数组示例  
          int[] arr = {1, 2, 3};
          modifyArray(arr);
          System.out.println("修改后数组: " + Arrays.toString(arr)); // 输出: [100, 2, 3]
      }
      
      public static void modifyString(String s) {
          s = "world"; // 创建了新对象，不影响原引用
      }
      
      public static void modifyArray(int[] array) {
          array[0] = 100; // 修改了原数组对象的内容
      }
  }
  ```

- 可变参数列表

  ```
  public void sum(int... n){}
  ```

  - 可变参数必须是最后一个
  - 一个方法只能有一个可变参数
  - 可变参数本质是数组
  - 优先匹配固定参数方法

  ```java
  public class VarargsDemo {
      
      // 可变参数方法
      public static void printNumbers(int... numbers) {
          for (int num : numbers) {
              System.out.print(num + " ");
          }
          System.out.println();
      }
      
      public static void main(String[] args) {
          printNumbers();           // 输出: (空行)
          printNumbers(1);          // 输出: 1
          printNumbers(1, 2);       // 输出: 1 2
          printNumbers(1, 2, 3, 4); // 输出: 1 2 3 4
      }
  }
  ```

  

## 第三周

### 类和对象

- 什么是面向对象? 关注事物信息

- 类 确定对象的特征+方法

- 对象是类的实例表现

  类---->实例化对象----->完成具体的程序

- 创建类与实例化对象

  ```java
  public class Person {
      // 属性（字段）
      String name;
      int age;
      
      // 方法
      public void introduce() {
          System.out.println("你好，我叫" + name + "，今年" + age + "岁。");
      }
      
      public void celebrateBirthday() {
          age++;
          System.out.println(name + "过生日啦！现在" + age + "岁了。");
      }
  }
  
  public class PersonTest {
      public static void main(String[] args) {
          // 实例化对象 - 使用 new 关键字
          Person person1 = new Person();
          
          // 设置对象的属性
          person1.name = "张三";
          person1.age = 25;
          
          // 调用对象的方法
          person1.introduce();
          person1.celebrateBirthday();
          
          // 创建另一个对象
          Person person2 = new Person();
          person2.name = "李四";
          person2.age = 30;
          person2.introduce();
      }
  }
  ```

  对象实例化后，对象的属性会有默认值(与方法不同)

- 单一职责原则

  一个类只有一个功能，只干一件事，功能越多，耦合越大，复用的可能性越低

  `PersonTest`如何找到的`Person`? 找本类，后找同一包

- new

  - 声明对象 `Person person1` 仅仅是栈中开辟空间，还不能真正使用
  - 实例化对象 `new Person();`堆中存数据，实例化后，栈中对象指向堆中的数据地址
  - 同一作用范围内，不能定义同名对象

### 堆与栈

- 当存储内容是由基本数据类型(byte、short、int、long、fioat、double、char、bolean)声明的局部变量时，在栈中存储的是它们对应的具体数值。
- 当存储的是局部的对象的引用(定义在方法体中的引用类型的变量)，存储的是具体对象在堆中的地址。当然，如果对象的引用没有指向具体的空间，则是null。

### 构造方法

- 构造方法与类同名且**没有返回值**

- 构造方法的语法格式

  ```java
  public 构造方法名(){
  	//初始化代码
  }
  ```

- 只有在对象实例化的时候被调用

- 当没有指定构造方法时，系统会自动添加无参的构造方法

- 当有指定构造方法，无论是有参、无参的构造方法，都不会自动添加无参的构造方法

- 一个类中可以有多个构造方法(重载)

### 封装

- 将类的某些信息隐藏在类内部，不允许外部程序直接访问
- 通过该类提供的方法来实现对隐藏信息的操作和访问
- 隐藏对象的信息
- 留出访问的接口

### 封装的代码实现

- 修改属性的可见性(private)，限定只能在当前类内访问 
- 创建getter/setter方法(public)
- 在getter/setter方法中加入属性控制语句

```java
public class Student {
    // 私有属性 - 外部无法直接访问
    private String name;
    private int age;
    private double gpa;
   
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
            this.name = name;
    }
    
    public int getAge() {
        return age;
    }
    
    public void setAge(int age) {
        if (age >= 0 && age <= 120) {
            this.age = age;
        } else {
            System.out.println("年龄必须在0-120之间！");
        }
    }
    
    public double getGpa() {
        return gpa;
    }
    
    public void setGpa(double gpa) {
            this.gpa = gpa;
    }
}
//测试类
public class StudentTest {
    public static void main(String[] args) {
        // 创建学生对象
        Student student = new Student();
        // 使用setter方法修改属性
        student.setAge(21);
        student.setGpa(3.9);
        student.setName("李四");
        // 调用getter方法
        System.out.println("学生1 - 姓名: " + student.getName() + 
                          ", 年龄: " + student.getAge() + 
                          ", GPA: " + student.getGpa());
    }
}
```



### 包

- Java中一个包里不能存在同名类
- 命名：域名倒序+模块+功能
- 导包用import
- 加载类的顺序跟import导入语句的位置无关,先找直接能解析的类
- `import 包名.*;` 只能访问指定包名下的类，无法访问子包下的类

### static关键字

- 表示静态信息，静态成员/类成员/全局属性
- 类对象共享
- 类加载时产生，销毁时释放，生命周期长
- 静态成员访问方式
  - 对象.成员
  - 类.成员
- 通过该类实例化的所有对象都共享类中静态资源，任一对象中信息的修订都将影响所有对象。
- 静态方法中不能直接调用同一类中的非静态成员，只能通过对象实例化
- 构造代码块--创建对象时调用，优先于构造方法执行(与构造方法同级)，每次实例化的时候都会执行
- 静态代码块--创建对象时调用，优先于构造代码块执行，多个按顺序执行，无论实例化多少对象，只执行一次，只能访问静态成员

### 继承

- 利用代码复用，缩短开发周期
- 一种类与类之间的关系
- 使用已存在的类的定义作为基础建设新类
- 子类的定义可以增加新的数据或功能，也可以使用父类的功能，但不能选择性的继承父类

### 继承的实现

- 简单演示

```java
//父类
class Animal{
	//公共的属性和方法
}

//子类
class Dog extends Animal{
    //子类特有的属性和方法
}
class Cat extends Animal{
}

```

- 一个子类只能有唯一父类

### 方法的重写

- 在子类中定义
- 方法名、参数(类型、顺序、个数)都要和父类相同，参数名不做要求
- 当子类重写父类方法后，子类对象调用的是重写后的方法
- 当方法返回值是void或基本数据类型时，不允许修改；当返回值是引用类型时，可以是父类或其子类
- 访问修饰符需要大于等于父类的访问修饰符
- 静态方法不能重写

### 访问修饰符

- 公有(public)：允许在任意位置访问
- 私有(private)：只允许在本类中进行访问
- 受保护的(protected)：允许在同类、同包子类/非子类、跨包子类调用
- 默认(啥也不写)：允许在当前类、同包子类/非子类调用，不允许跨包

### super关键字

在子类中，如果一个方法重写后，子类中另一个方法仍然想调用继承下来的同名方法，可以使用`super.方法名`

### 继承后的初始化顺序

父类静态成员--->子类静态成员-->父类对象构造-->子类对象构造

**子类构造默认调用父类无参构造方法，可以用super指定调用父类的哪个构造方法**

```java
// 父类
class Parent {
    private String name;
    private int age;
    
    // 父类无参构造方法
    public Parent() {
        this.name = "未知";
        this.age = 0;
        System.out.println("调用了父类无参构造方法");
    }
    
    // 父类有参构造方法
    public Parent(String name, int age) {
        this.name = name;
        this.age = age;
        System.out.println("调用了父类有参构造方法：name=" + name + ", age=" + age);
    }
}

// 子类
class Child extends Parent {
    private String hobby;
    
    // 子类构造方法1：默认调用父类无参构造方法（隐式调用）
    public Child(String hobby) {
        // 这里隐式调用了 super()，即父类的无参构造方法
        this.hobby = hobby;
        System.out.println("调用了子类构造方法1，hobby=" + hobby);
    }
    
    // 子类构造方法2：使用super显式调用父类有参构造方法
    public Child(String name, int age, String hobby) {
        super(name, age); // 显式调用父类有参构造方法，必须放在第一行
        this.hobby = hobby;
        System.out.println("调用了子类构造方法2，hobby=" + hobby);
    }
}
```

## 第四周

### Object类

- object类是所有类的父类

- 一个类没有使用extends关键字明确标识继承关系，则默认继承Object类(包括数组)

- Java中的每个类都可以使用Object中定义的方法

- 继承object中的equals方法时，比较的是两个引用是否指向同一个对象

- 子类可以通过重写equals方法的形式，改变比较的内容

- 字符串重写了equals方法，比较的是内容

- 输出对象名时，默认会直接调用类中的toString方法，object类中的toString方法是打印包名@内存地址哈希，在实体类中经常被重写

  > 问:`==`到底比较的是值还是地址呢?
  >
  > 答：比较的是变量中存储的值，对于基本数据类型，比较栈中的实际数值，引用数据类型 - 比较栈中存储的引用地址

### final关键字

- final class表示该类没有子类，禁止继承
- final 方法表示该方法不能被子类重写，但是不影响子类继承使用(不能修饰构造方法)，禁止重写
- final 局部变量 表示该变量只能被赋值一次，变为常量
- final 对象属性亦如此，但是有三种赋值方式：1、定义时赋值 2、构造方法中赋值3、构造代码块中赋值
- 可配合static使用，表示全局加载一次且不能被修改

### 注解

- 可以声明在包、类、属性、方法、局部变量、方法参数等的前面，用来对这些元素进行说明、注释
- 按照运行机制分为三类
  - 源码注解:注解只在源码阶段保留在编译阶段会被丢弃
  - 编译时注解
  - 运行时注解：在运行阶段还起作用，甚至会影响运行逻辑的注解。
- 按照来源分
  - 来自JDK的注解
  - 来自第三方的注解
  - 我们自己定义的注解

### Java单例模式

- 什么是设计模式？设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。
- 目的:使得类的一个对象成为该类系统中的唯一实例
- 一个类有且只有一个实例，并且自行实例化向整个系统提供
- 实现：
  1. 只提供私有的构造方法
  2. 含有一个该类的静态私有对象
  3. 提供一个静态的共有方法用于创建、获取静态私有对象
- 优：
  - 在内存中只有一个对象，节省内存空间
  - 避免频繁的创建销毁对象，提高性能
  - 避免对共享资源的多重占用
- 缺：
  - 扩展困难
  - 如果实例化后的对象长期不利用，系统将默认为垃圾进行回收，造成对象状态丢失

### 饿汉式单例模式

- 对象创建过程中实例化
- 空间换时间

代码实现演示:

```java
package com.qy.singleton;

public class SingletonOne {
    //创建私有构造方法
    private SingletonOne() {
    }
    //私有静态实例化对象
    private  static SingletonOne singletonOne = new SingletonOne();

    //共有静态方法返回静态实例对象
    public static SingletonOne getSingleton(){
        return singletonOne;
    }

}

package com.qy.test;

import com.qy.singleton.SingletonOne;

public class SingletTest {
    public static void main(String[] args) {
        //使用类.方法调用
        SingletonOne one = SingletonOne.getSingleton();
        SingletonOne two = SingletonOne.getSingleton();

        System.out.println(one);
        System.out.println(two);

    }
}

```

![image-20251025185442620](\img\linux\image-20251025185442620.png)

### 懒汉式单例模式

- 静态公有方法中实例化
- 类内实例对象创建时并不直接初始化，直到第一次调用get方法时，才完成初始化操作
- 时间换空间
- 存在线程风险
  - 同步锁
  - 双重校验锁
  - 静态内部类
  - 枚举

代码实现:

```java
package com.qy.singleton;
public class SingletonTwo {
    //创建私有构造方法
    private SingletonTwo() {
    }
    //私有静态实例化对象
    private  static SingletonTwo singletonTwo;

    //共有静态方法返回静态实例对象
    public static SingletonTwo getSingleton(){
        if(singletonTwo == null){  //如果不加判断，就违背了单例模式的初衷，重复创建和销毁对象
            singletonTwo = new SingletonTwo();
        }
        return singletonTwo;
    }
}

package com.qy.test;
import com.qy.singleton.SingletonTwo;

public class SingletTest {
    public static void main(String[] args) {
        //使用类.方法调用
        SingletonTwo singletonOne = SingletonTwo.getSingleton();
        SingletonTwo singletonTwo = SingletonTwo.getSingleton();
        System.out.println(singletonOne);
        System.out.println(singletonTwo);

    }
}
```

